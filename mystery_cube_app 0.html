<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mystery Cube (No external libs)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1020;              /* page bg */
      --brown:rgb(138,84,74);    /* top face (light brown) */
      --blue:rgb(183,198,204);   /* light blue */
      --dblue:rgb(99,148,199);   /* blue */
      --face-size: 260px;        /* cube face size */
      --text:#0b1020;            /* label color */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
    #stage{position:fixed;inset:0;display:grid;place-items:center;}
    .scene{width:min(90vmin,560px);height:min(90vmin,560px);position:relative;perspective:900px;}

    /* Centered pivot the cube rotates around */
    .pivot{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-style:preserve-3d;transform-origin:50% 50% 0;}

    /* Cube container at origin; faces extend out by translateZ(face/2) */
    .cube{position:relative;transform-style:preserve-3d;width:var(--face-size);height:var(--face-size);will-change:transform;user-select:none;-webkit-user-select:none;transform-origin:50% 50% 0}

    .face{left:0;top:0;
      position:absolute;width:var(--face-size);height:var(--face-size);
      display:flex;align-items:center;justify-content:center;
      backface-visibility:hidden;box-shadow:0 12px 30px rgba(0,0,0,.25) inset, 0 6px 30px rgba(0,0,0,.25);
      user-select:none;-webkit-user-select:none
    }
    .blank{box-shadow:none}

    /* labels */
    .label{position:absolute;color:var(--text);font-weight:900;user-select:none;-webkit-user-select:none}
    .label.center{font-size:44px;letter-spacing:.5px;text-transform:uppercase;}
    .label.ur{top:10px;right:12px;font-size:28px}
    .label.ll{bottom:10px;left:12px;font-size:28px}

    /* helper UI */
    .hint{position:fixed;left:12px;bottom:12px;padding:8px 10px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);border-radius:10px;font-size:12px;backdrop-filter:blur(6px);user-select:none;-webkit-user-select:none}

    /* center cube nicely on small screens */
    @media (max-width:640px){:root{--face-size:220px}.label.center{font-size:36px}.label.ur,.label.ll{font-size:24px}}
  </style>
</head>
<body>
  <div id="stage">
    <div class="scene" id="scene">
      <!-- If #pivot is missing (older copies), the script will create it and move #cube inside. -->
      <div class="pivot" id="pivot">
        <div class="cube" id="cube">
          <!-- FRONT (+Z) — Side 2: 2 ALFRED 6 — light blue -->
          <div class="face" data-face="front" style="background:var(--blue); transform: translateZ(calc(var(--face-size)/2));">
            <span class="label ur">6</span>
            <span class="label ll">2</span>
            <span class="label center">ALFRED</span>
          </div>
          <!-- BACK (-Z) — Side 4: 2 ALMA 4 — light blue (opposite matches) -->
          <div class="face" data-face="back" style="background:var(--blue); transform: rotateY(180deg) translateZ(calc(var(--face-size)/2));">
            <span class="label ur">4</span>
            <span class="label ll">2</span>
            <span class="label center">ALMA</span>
          </div>
          <!-- RIGHT (+X) — Side 1: 3 ROBERTA 7 — blue -->
          <div class="face" data-face="right" style="background:var(--dblue); transform: rotateY(90deg) translateZ(calc(var(--face-size)/2));">
            <span class="label ur">7</span>
            <span class="label ll">3</span>
            <span class="label center">ROBERTA</span>
          </div>
          <!-- LEFT (-X) — Side 3: 3 ROB 3 — blue (opposite matches) -->
          <div class="face" data-face="left" style="background:var(--dblue); transform: rotateY(-90deg) translateZ(calc(var(--face-size)/2));">
            <span class="label ur">3</span>
            <span class="label ll">3</span>
            <span class="label center">ROB</span>
          </div>
          <!-- TOP (+Y) — Top: 4 FRANK 5 — light brown -->
          <div class="face" data-face="top" style="background:var(--brown); transform: rotateX(90deg) translateZ(calc(var(--face-size)/2));">
            <span class="label ur">5</span>
            <span class="label ll">4</span>
            <span class="label center">FRANK</span>
          </div>
          <!-- BOTTOM (-Y) — blank -->
          <div class="face blank" data-face="bottom" style="background:#2a2f45; transform: rotateX(-90deg) translateZ(calc(var(--face-size)/2));"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="hint">Drag to rotate • Scroll/Pinch to zoom • Double-click to reset</div>

  <script>
    // Arcball-like rotation about the cube's true center with structural fixes to avoid drift/size shift
    (function(){
      function init(){
        const scene = document.getElementById('scene');
        let pivot = document.getElementById('pivot');
        const cube = document.getElementById('cube');

        if(!pivot){
          pivot = document.createElement('div');
          pivot.className = 'pivot';
          pivot.id = 'pivot';
          cube.parentNode.insertBefore(pivot, cube);
          pivot.appendChild(cube);
        }

        // Ensure pivot is perfectly centered and has no size
        pivot.style.transformOrigin = '50% 50% 0';
        pivot.style.willChange = 'transform';

        let dragging = false, lastX = 0, lastY = 0;
        let scale = 1;
        let M = new DOMMatrix();

        function apply(){
          // Center first, then apply pure rotation, then uniform scale; no translation terms in M
          const t = `translate(-50%,-50%) matrix3d(${[
            M.m11,M.m12,M.m13,M.m14,
            M.m21,M.m22,M.m23,M.m24,
            M.m31,M.m32,M.m33,M.m34,
            0,0,0,1
          ].join(',')}) scale3d(${scale},${scale},${scale})`;
          pivot.style.transform = t;
        }

        function setInitial(){
          scale = 1;
          M = new DOMMatrix();
          M = M.rotateSelf(-22, 0, 0); // X
          M = M.rotateSelf(0, 28, 0);  // Y
          apply();
        }

        scene.addEventListener('pointerdown', e=>{ dragging = true; lastX = e.clientX; lastY = e.clientY; try{scene.setPointerCapture(e.pointerId)}catch(_){} });
        scene.addEventListener('pointermove', e=>{
          if(!dragging) return;
          const dx = e.clientX - lastX; const dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY;
          const RY = new DOMMatrix().rotateSelf(0, dx * 0.35, 0);
          const RX = new DOMMatrix().rotateSelf(dy * 0.35, 0, 0);
          // Pre-multiply to rotate in view space
          M = RX.multiply(RY.multiply(M));
          apply();
        });
        scene.addEventListener('pointerup', e=>{ dragging = false; try{scene.releasePointerCapture(e.pointerId)}catch(_){} });
        scene.addEventListener('pointercancel', ()=>{ dragging = false; });

        scene.addEventListener('wheel', e=>{ e.preventDefault(); scale *= (e.deltaY < 0 ? 1.1 : 0.9); scale = Math.max(0.5, Math.min(2.5, scale)); apply(); }, {passive:false});
        scene.addEventListener('dblclick', setInitial);

        // -------------------------
        // Added self-tests: view-consistent centering/scale across faces
        // -------------------------
        (function faceAlignmentTest(){
          try{
            const front = document.querySelector('[data-face="front"]');
            const right = document.querySelector('[data-face="right"]');
            const saveM = M;

            // Helper to measure center and width of currently front-facing face
            function centerAndWidth(el){
              const r = el.getBoundingClientRect();
              return { cx: r.left + r.width/2, w: r.width };
            }

            // Face FRONT
            M = new DOMMatrix();
            apply();
            const a = centerAndWidth(front);

            // Face RIGHT (rotate Y 90deg)
            M = new DOMMatrix().rotateSelf(0, 90, 0);
            apply();
            const b = centerAndWidth(right);

            // Restore matrix
            M = saveM; apply();

            const dx = Math.abs(a.cx - b.cx);
            const dw = Math.abs(a.w - b.w);
            console.assert(dx < 2, `Centers should align (Δx=${dx.toFixed(2)}px)`);
            console.assert(dw < 2, `Face sizes should match (Δw=${dw.toFixed(2)}px)`);
          }catch(err){ console.warn('Alignment self-test skipped/failed:', err); }
        })();

        setInitial();

        // Expose small debug API
        window.__mysteryCube__ = { pivot, cube, setMatrix: (rx,ry)=>{ M = new DOMMatrix().rotateSelf(rx,0,0).rotateSelf(0,ry,0); apply(); } };
      }

      if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
  </script>
</body>
</html>
